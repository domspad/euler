About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:32
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 1 to 25 out of 201


This one was rather easy. Instead of trying to explain, I'm posting my source code in C.

C/C++


Using the fact that a point lies on the interior of a convex polygon if and only if it lies to the same side of each line segment (when viewed as a path), a quick solution in K (http://kx.com):




Very similar to this problem. I didn't notice until I saw stubbscroll solution (I solved that one the same way).

This time I used a function I already had coded to know if a point is inside a polygon or not (in Pascal):


Here a is the array containing the polygon (the coordinates), c is an array indicating the order the points must be visited (c[0] indicates how many points the polygon has) and p is the point being checked. If the point is inside then d equal to zero or to c[0], it depends whether the points are given clockwise or counter-clockwise.
Permanent post


This wasn't the most difficult problem. My code:

Java

How should we treat the edges? 
Permanent post

Mon, 1 Aug 2005, 22:14 
void*  
Sweden	
   Quote   Report    0
I overcomplicated the code, but basically I did:

n=0 // no of triangles with origin

for ( /* each line in triangles.txt */ )
   point a,b,c
   a.x = // ...
   a.y = // ...
   // ...

   a1=angle(a,b)
   a2=angle(a,c)
   a3=angle(b,c)

   if (a1+a2+a3==360) n++
Permanent post


I just checked the sign of the cross products

C/C++


Use Heron's formula for the area of a triangle
given the lengths a,b,c of the sides
   A = sqrt s*(s-a)*(s-b)*(s-c)
where s is the semiperimeter 0.5*(a+b+c).

Apply Heron's formula to the whole triangle.
Apply Heron's formula to the 3 triangles formed 
by the origin and each of the 3 pairs of points.  
The origin is in the interior if the area of the 
whole triangle equals the sum of the areas of the 
3 triangles.
Permanent post


I thought there was a simple algorithm to solve this but I had forgotten it, so I also used the Heron method.
Permanent post


Not that hard to solve, but I think it's nice that Euler mixes both harder and easier problems to keep the site interesting for all kinds of users.

My approach was that for the origin to be inside the triangle there has to be one line above or at the origin and one beneath or at the origin. 
Permanent post


I first rejected all triangles where the x coordinates or the y coordinates all had the same sign.

I then computed the intersection points of the two sides which were intersecting the x axis (the same could be done with the y axis). The origin was inside only if these two intersection points had opposite signs.

Although the wording of the problem was "for which the interior contains the origin", I still checked if any side was bisecting the origin. However, none of the listed triangles had that property.

(Less than 1 ms in assembly, including reading the text file, parsing it, converting from ASCII to binary and performing all the computation.)
Permanent post


Letting A,B,C denote the corners of the triangle, I Looked at the lines A0 and BC. The extension of A0 must intersect BC, but not the line itself. When implemented the method still ends up using the same cross products as some of you. It is also general, and any point can be tested.
Permanent post


RogerHui and Ron Rotkin, I also used the area of triangle method, but there is an easier way...

Given A(x1,y1), B(x2,y2), C(x3,y3), let p=x1-x3, q=y1-y3, r=x2-x3, s=y2-y3, then the area = 0.5*abs(p*s-q*r).

In fact, if we have a 3x3 matrix M=(x1 y1 1)(x2 y2 1)(x3 y3 1) [given as top, middle, and bottom row], then 0.5*det(M) also gives the area.
Permanent post


What euler said is correct, except he forgot to add thats its the absolute value of the determinant. It will sometimes turn out negative based on the position of the triangle in the coordinate system.

~Zef
Permanent post


In n-space the determinant gives the signed volume,
so the sign is significant.  It's just that for 
problem 102 we only want the absolute value of the 
volume (area in 2-d).
Permanent post


Used cross products to find on which side of an edge the origin is. If the origin is on the same side of all edges, the origin is inside the triangle.

In C++:
C/C++

Permanent post


Permanent post


If you check out the "About" section it explains that new problems are initially worth 20 point. This is because a problem is worth more points if less people have solved it, and when it is first release no one has solved it. If it turns out to be a genuinely difficult problem it will remain solved by few people and will always be a high scoring problem. If, however, as you suggest it is not such a difficult problem then it will be solved by more people and it will become worth less points. Remember the scoring system is dynamic and as more people solve a particular problem you've already solved your points will change. (c;
Permanent post

Mon, 8 Aug 2005, 09:47 
  	
   Quote   Report    0
Oh, that's a really neat idea. Thanks for explaining that and sorry I skipped that section! :)
Permanent post


I first discarded all the triangles which didnt have both negative and positive values of x and y, which got me down to 550. 

Then I calculated where each of the three lines would cross the x- and y-axis, and if it happened between the two points. If the three lines together crossed all four axes (positive and negative, y and x) then it included the origin.
Permanent post


Haven't seen any boundary problems. What I mean is, that there wasn't a single triangle where the origin was actually ON the edge. As the problem clearly states "interior". this would have been a nice pit fall }:-D.

Also, there where no degenerate triangles (three points on one line / no (real) interior). Might have been a pit fall for some.

Oh well, just used another standard algorithm from my programming contest collection. Indeed, not a hard problem.
Permanent post


Well, my method is this:
Let's call triangle ABC, now draw AO, BO, CO. If O is inside the triangle, angles AOB, BOC, COA are <pi, if O is outside then one of these angles must be >pi.

Python


Creating 3 smaller triangles from the triangle coords and the origin point, then checking if that area is not greater than the triangle area.

In C++:
C/C++


I have to admit I solved it graphically (drawing them up and check pixelcolor/or on top of origo) :p I was planning on solving it via dividing up into cases like someone else said and then compute the coord where the lines cuts the X-axis.. but it's 5 am :p you do what you gotta do (6 lines with the imports)

EDIT: may as well post the code:

  from Tkinter import *
  canvas = Canvas()
  trifil = open("triangles.txt")

  triangles = ( [[int(ss) for ss in line.split(",")] for line in trifil] )
  tri = [canvas.create_polygon([(c[0], c[1]), (c[2], c[3]), (c[4], c[5])]) for c in triangles]

  print len(canvas.find_overlapping((0),(0),(0),(0)))

How do you get the nice Code-area (with usually yellow background)?
Permanent post


It is interesting to see so many different approaches.

For the 3 vertices of a triangle A,B and C, and the origin O,  my strategy was to 
1 - Calculate the vectors AO, BO, CO
2 - Calculate the (subtended) angle between each of the vectors around O (all three angles should add up to 360deg)
3 - If one of the 3 angles is >180deg then O is not inside (or on a side! for just interior use >=180) the triangle.

Apologies if someone else mentioned this already, and I just didn't see it.

thx
Caleb
Permanent post


Solution: excel.
The first columns are the coordinates.
Then I compute the cross products AxB, BxC, CxA.
If all these cross products are >0 or all are <0, the origin is within the triangle, else, it is not.  (depending on the sign, the triangle turns clockwise or counterclockwise around the origin).
Permanent post


123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy
Loading [MathJax]/extensions/Safe.js
About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:32
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 26 to 50 out of 201


Same approach as Kaleb. The only difference was that for each of those 3 angles between vectors, I took always the smaller possible angle. I used absolute values all the time.
The final test was then; If the 3 smaller angles add to 360 (2Pi) the origin was inside.
Best,
Rudy.
Permanent post


Another solution:

Consider the (complex) curve integral along a curve C for the function f(z) = 1/z.

If C contains the origin, the integral has value +-2*i*pi. If it does not, the integral is 0.

I calculated the curve integral along each of the triangles numerically.
Permanent post


J:


My method is rather simple. One line must intersect the y-axis above and one below the y-axis. The other line mustn't intersect at all! :)
Permanent post


JavaManIssa:

What about (1,0) (1,-1) (-1,-1) ?
Permanent post


A bit complicated K


Wow! I'm amazed that so many people came up with so
many different approaches!
I essentially did what void* did.  Here is my python code:
Python


Here's my Ruby code, using Barycentric coordinates.  I usually use Haskell for these challenges, but Ruby is just so much easier when dealing with file and string manipulation.

Haskell


lth said
JavaManIssa:

What about (1,0) (1,-1) (-1,-1) ?


That doesn't intersect the y-axis above 0, so it doesn't contain the origin.
Permanent post


JavaManIssa said
lth said
JavaManIssa:

What about (1,0) (1,-1) (-1,-1) ?


That doesn't intersect the y-axis above 0, so it doesn't contain the origin.


That requires your program to handle vertial lines.
How does it handle the case that one of the vertices is on the y-axis?
E.g. (0,1) (1,-1) (-1,-1)
To be more precise: two lines intersect the y-axis above the x-axis and one below.
Permanent post


used the same solution has "neverforget" because it's very eficient, I based on this page (it's for 3d but i adapted),
http://gehennom.net/~fozzlebot/vector/

in scheme (Graphical: (MrEd, includes MzScheme)):

(require (lib "math.ss")
         (lib "13.ss" "srfi"))

(define newvect
  (lambda (x y)
    (cons x y)))

(define newtriangle
  (lambda (a b c)
    (vector a b c)))

(define vectprod
  (lambda (v1 v2)
    (+
     (* (car v1) (car v2))
     (* (cdr v1) (cdr v2)))))

(define vectnorm
  (lambda (v)
    (sqrt (+ (sqr (car v)) (sqr (cdr v))))))

(define vectcos
  (lambda (v1 v2)
    (/ (vectprod v1 v2)
       (* (vectnorm v1) (vectnorm v2)))))

(define vectsub
  (lambda (v1 v2)
    (newvect
     (- (car v1) (car v2))
     (- (cdr v1) (cdr v2)))))

(define vectrotate90
  (lambda (v)
    (newvect
     (* (cdr v) -1)
     (car v))))

(define edgenorm
  (lambda (p1 p2)
    (vectrotate90 (vectsub p2 p1))))

(define hasorigin?
  (lambda (t)
    (let (
     (a
        (vectprod
         (vector-ref t 0)
         (vectrotate90
          (vectsub (vector-ref t 0) (vector-ref t 1)))))
     (b
        (vectprod
         (vector-ref t 1)
         (vectrotate90
          (vectsub (vector-ref t 1) (vector-ref t 2)))))
     (c
        (vectprod
         (vector-ref t 2)
         (vectrotate90
          (vectsub (vector-ref t 2) (vector-ref t 0))))))
     (or (and (< 0 a) (< 0 b) (< 0 c))
              (and (> 0 a) (> 0 b) (> 0 c))))))

(define readvect 
  (lambda (f)
    (let ((x (read f)) (y (read f)))
      (if (or (eof-object? x) (eof-object? y))
          y
          (newvect x y)))))

(define readtriangle
  (lambda (f)
    (let ((a (readvect f)) (b (readvect f)) (c (readvect f)))
      (if (or (eof-object? a) (eof-object? b) (eof-object? c))
          c
      (newtriangle a b c)))))

(define readtrilist
  (lambda (f)
    (let ((t (readtriangle f)))
      (if (eof-object? t)
          ()
          (cons t (readtrilist f))))))

(how-many-have-origin? (readtrilist (open-input-file "triangles.txt")))
Permanent post


This wasnt that easy for me mostly because I'm clueless about geometry.  THe observation I used (slightly similar to Javaman) is that all 4 axis must be crossed.

My code is very fast, but it is fairly long due to a lot of if statements. -- ommited because its not so pretty.

On second look, Java's method simplifies the code a great deal, and also produces the correct solution.  But you can drop the requirement about checking if the 3rd line also intercepts y because it wont :)
Permanent post


Common Lisp:
LISP

Real time: 0.014 sec.
Run time: 0.015 sec.
Space: 134984 Bytes
228
Permanent post


I used the observation that, in order for the triangle to contain the origin, at least two of the triangle sides had to intersect the x axis.  (It works for either axis, of course; I happened to choose x.)  Not quite so elegant as some of the other solutions, but it works.  Common Lisp, as usual.

LISP


I determined the system of equations to draw the triangle, and checked if the origin was a solution:


A helpful link:

http://www.blackpawn.com/texts/pointinpoly/default.html
Permanent post


I checked to see how many of the triangle's segments intersect the ray x = 0, y >= 0. If 1, then the origin is in the triangle. If 0 or 2, it isn't.

Point = Struct.new("Point", :x, :y)

class Segment
    attr_accessor :pa, :pb, :slope, :x_intercept

    def initialize(pa, pb)
        @pa, @pb = pa, pb
        
        @slope = (pb.x - pa.x != 0) ? (pb.y - pa.y) / (pb.x - pa.x) : :undefined
        
        @x_intercept = case @slope
                       when :undefined then pa.x
                       when 0 then pa.y == 0 ? :superimposed : :undefined
                       else pa.x - pa.y / @slope end
    end
end

# Returns non-false if the segment intersects the ray (x = 0, y >= 0)
def intersect?(seg)
    seg.x_intercept.is_a?(Numeric) && seg.x_intercept >= 0 && (seg.pa.y <=> 0) != (seg.pb.y <=> 0)
end

triangles = File.open("102.data") do |f|
    f.map do |line|
        vertices = [[], [], []]
        line.split(",").each_with_index { |token, i| vertices[i / 2] << token.to_f }
        vertices.map { |p| Point.new(*p) }
    end
end

total = 0
triangles.each do |t|
    segments = [Segment.new(t[0], t[1]), Segment.new(t[1], t[2]), Segment.new(t[2], t[0])]
    intersections = 0
    segments.each { |s| intersections += 1 if intersect?(s) }
    total += 1 if intersections % 2 == 1
end

puts total
Permanent post


Hi all,

what about sides that contains the origin?
many of you worked with "inside" as points over or below a side, so a point along a side is "inside" or "outside"? I think is inside.
So i have worked using semiperimeter of the 3 triangles formed from center to the other 3 points. The sum of the three areas must be equal to the given triangle area if center is inside.

best regards

Miguel

 
Permanent post


This is my solution in Postscript. The infill operator
does the main work. To run: gs code.ps

Python


My algorithm:

The origin is within triangle ABC if between line segments AB, AC, BC there are positive and negative intersections on both x and y axes.
Permanent post


PostgreSQL does all the work for you:

Python



My cross product solution is slightly less efficient than others; I'm moderately upset that I didn't figure out the other way.  I take four cross products:

c1 = origin->vertex1 cross vertex1->vertex2
c2 = origin->vertex1 cross vertex1->vertex3

If c1*c2 < 0 (the cross products have opposite signs), the origin is between the lines formed by vertex1->vertex2 and vertex1->vertex3.

c3 = origin->vertex2 cross vertex2->vertex1
c4 = origin->vertex2 cross vertex2->vertex3

Likewise for c3*c4 < 0...

If both c1*c2 < 0 and c3*c4 < 0, then the origin is inside the triangle.
Permanent post


Okay, I managed to pick THE most awkward way to do this. I compared angles - if the point is inside the triangle, then it forms angles less than those inside the triangle. Awkward to explain, too.
In c:
C/C++


EDIT: ^^ My lines are so long they distort the page layout ^^. Sorry Euler! (Note: In my editor, it's six lines long, since I gave one line per function.)
Permanent post


No problem, carl. You alerted me to a glitch in my code; I think I've managed to fix it.
Permanent post


In Mathematica.

Mathematica

(edited June '07 for formatting)
Permanent post


123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy
About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:32
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 51 to 75 out of 201


The following solution in Common Lisp is easily generalised to determine if any point lies inside any shaped polygon (not just regular polygons).

Common Lisp:


(defstruct point
  (x 0 :type fixnum)
  (y 0 :type fixnum))



(defstruct line
  (p1 (make-point :x 0 :y 0))
  (p2 (make-point :x 0 :y 0)))



(defun same-side-p (line point1 point2)
  "Determine if POINT1 and POINT2 are on the same side of LINE."
  (let* ((line-p1-x (point-x (line-p1 line)))
         (line-p2-x (point-x (line-p2 line)))
         (line-p1-y (point-y (line-p1 line)))
         (line-p2-y (point-y (line-p2 line)))
         (dx-line (- line-p2-x line-p1-x))
         (dy-line (- line-p2-y line-p1-y))
         (dx1 (- (point-x point1) line-p1-x))
         (dy1 (- (point-y point1) line-p1-y))
         (dx2 (- (point-x point2) line-p2-x))
         (dy2 (- (point-y point2) line-p2-y)))
    (> (* (- (* dx-line dy1)
             (* dy-line dx1))
          (- (* dx-line dy2)
             (* dy-line dx2)))
       0)))



(defun intersect-p (line1 line2)
  "Determine if LINE1 intersects LINE2. Collinear lines are deemed to
intersect."
  (and (not (same-side-p line1 (line-p1 line2) (line-p2 line2)))
       (not (same-side-p line2 (line-p1 line1) (line-p2 line1)))))



(defun inside-triangle (point tri-p1 tri-p2 tri-p3)
  "Determine if POINT lies inside the triangle define by points
TRI-P1, TRI-P2 and TRI-P3."
  (let* ((max-x 1000)
         (max-y 1000)
         (inf (make-point :x max-x :y max-y))
         (try-line (make-line :p1 point :p2 inf))
         (edges (make-array 3
                            :initial-contents
                            (list (make-line :p1 tri-p1 :p2 tri-p2)
                                  (make-line :p1 tri-p2 :p2 tri-p3)
                                  (make-line :p1 tri-p3 :p2 tri-p1))))
         (count (loop for edge across edges
                      when (intersect-p try-line edge)
                      sum 1 into intersections
                      finally (return intersections))))
    (oddp count)))



(defun origin-inside-triangle (tri-p1 tri-p2 tri-p3)
  "Determine if the origin lies inside the triangle define by points
TRI-P1, TRI-P2 and TRI-P3."
  (let ((origin (make-point :x 0 :y 0)))
    (inside-triangle origin tri-p1 tri-p2 tri-p3)))



(defun euler-102 ()
  "Using triangles.txt, a 27K text file containing the co-ordinates of
one thousand 'random' triangles, find the number of triangles for
which the interior contains the origin."
  (with-open-file (rom-stream (merge-pathnames "lisp/triangles.txt"
                                               (user-homedir-pathname)))
    (loop for p1x = (read rom-stream nil 'eof)
          until (eq p1x 'eof)
          for p1y = (read rom-stream nil 'eof)
          for p2x = (read rom-stream nil 'eof)
          for p2y = (read rom-stream nil 'eof)
          for p3x = (read rom-stream nil 'eof)
          for p3y = (read rom-stream nil 'eof)
          when (origin-inside-triangle (make-point :x p1x :y p1y)
                                       (make-point :x p2x :y p2y)
                                       (make-point :x p3x :y p3y))
          sum 1 into count
          finally (return count))))

Permanent post


I checked if the origin was on the same side of the lines AB BC and CA. In scheme:


Permanent post


int y = 1;

The following code checks that the origin and a vertex lie on the same side of the line formed by the other two vertices.  m is the slope of the line and b is the y-intercept.



I computed the barycentric coordinates of the origin for each triangle.  If all three of the barycentric coordinates are positive, the origin lies within the triangle.

module Euler102 where

  import System.IO
  import Text.Regex

  type Point = (Int, Int)
  type Triangle = [Int]
  
--  baryCoord :: Point -> Triangle -> (Float, Float, Float)
  baryCoord (px, py) (x1:y1:x2:y2:x3:y3:[]) = (b1, b2, b3)
    where
      d = fromIntegral ((y1 - y3)*(x2 - x3) + (y2 - y3)*(x3 - x1))
      b1 = fromIntegral ((py - y3)*(x2 - x3) + (y2 - y3)*(x3 - px)) /  d
      b2 = fromIntegral((py - y1)*(x3 - x1) + (y3 - y1)*(x1 - px)) /  d
      b3 = fromIntegral((py - y2)*(x1 - x2) + (y1 - y2)*(x2 - px)) /  d
  
--  baryInTriangle :: (Float, Float, Float) -> Bool
  baryInTriangle (b1, b2, b3) = (b1 >= 0) && (b2 >= 0) && (b3 >= 0)
  
  triangleContainsOrigin = baryInTriangle . baryCoord (0,0)
  
--  buildTriangle :: String -> Triangle
  buildTriangle s = map read (splitRegex (mkRegex ",") s) :: [Int]
  
--  countTriangles :: [Triangle] -> Int
  countTriangles = length . filter triangleContainsOrigin

  process = show . countTriangles . map buildTriangle . lines
  
  main = do
    contents <- readFile "c:\\triangles.txt"
    (putStrLn . process) contents
Permanent post


If the point D is contained by the triangle ABC, construction of the triangles ABD, BCD, and CAD will all happen in the same direction (all clockwise or all counter-clockwise). If the point D is outside of the triangle, one of the orientations of the constructed triangles will not match the others.

My python code:

Python


Wow, I've don't think I've ever seen so few Haskell solutions! Oh well, I did it using crossproducts, comparing areas basically (simplified it some first though):
Haskell


Let A,B,C be the points of the triangle and O the origin
I considered the arrays AB, AC, AO 
When AB and AC are non-colinear I solved the equation AO=mAB+nAC
If m,n>0 and m+n<1 then O is inside the triangle 
Permanent post


<p><img src='images/correct.gif' width='89' height='59' alt='Correct' title='Corret' align='middle' /> Congratulations, the answer you gave to problem 102 is correct.</p>
<hr>
<h2> thanks to Kamal BOUCHENTOUF-INPT!</h2>
<hr>
i use the rule that O is in the interior of ABC
<=> (OAB) + (OBC) +(OAC) = (ABC)
(.) means the area of .
<hr>
My code
<hr>
 int abs(int a){
     if(a > 0)
       return a;
       return -a;
     }
int surface(int x1,int y1,int x2,int y2,int x3,int y3){
     
     return abs((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
     
     
     
     }
bool contains(int x1,int y1,int x2,int y2,int x3,int y3){
       int s = surface(x1,y1,x2,y2,x3,y3);
       int a = surface(0,0,x2,y2,x3,y3);
       int b = surface(x1,y1,0,0,x3,y3);
       int c = surface(x1,y1,x2,y2,0,0);
       
       return (a + b + c == s);
       }
int main(){
    FILE* in = fopen("triangles.txt","r");
  
    int x1,y1,x2,y2,x3,y3;
    int t = 0;
    while(fscanf(in,"%d,%d,%d,%d,%d,%d\n",&x1,&y1,&x2,&y2,&x3,&y3) == 6)
          t+=contains(x1,y1,x2,y2,x3,y3);
       
    printf("%d\n",t);
    getchar();
    
    
    return 0;
    }
<hr> 
Permanent post


#  Ruby 330 ms

require 'myutils'

def Point(x,y)
  Point.new(x,y)
end

class Point
  def initialize(x,y)
    @x=x
    @y=y
  end
  def x
    @x
  end
  def y
    @y
  end
  def -(p)
    Point.new(self.x-p.x, self.y-p.y)
  end
end

def crossProduct(a,b)
  a.x * b.y - a.y * b.x 
end

def dotProduct(a,b)
  a.x * b.x + a.y * b.y 
end

def sameSide(p1,p2,a,b)
  cp1 = crossProduct(b-a, p1-a)
  cp2 = crossProduct(b-a, p2-a)
  cp1 * cp2 >= 0
end

def pointInTriangle(p,a,b,c)
  sameSide(p,a,b,c) and sameSide(p,b,a,c) and sameSide(p,c,a,b)
end

def countTriangles(filename)
  res = 0 
  File.open(filename) do |file|
    file.each_line do |line|
      arr = line.chomp.split(/,/).collect {|x| x.to_i}
      p1=Point(arr[0],arr[1])
      p2=Point(arr[2],arr[3])
      p3=Point(arr[4],arr[5])
      res += 1 if pointInTriangle(Point(0,0), p1, p2, p3)
    end
  end
  res 
end

#-------------------------#

tick

assert 50, crossProduct(Point(20, 30), Point(45,70))
assert 3000, dotProduct(Point(20, 30), Point(45,70))

origin = Point(0,0)
assert true, pointInTriangle(origin, Point(-340,495), Point(-153,-910), Point(835,-947))
assert false, pointInTriangle(origin, Point(-175,41), Point(-421,-714), Point(574,-645))

assert 228, countTriangles('102.txt')

tack 




Permanent post


No coding here (couldn't bother to spend so much time with writing).

OpenOffice Calc sheet ... importing data ... entering like 8 formulas and Fill->Down .. COUNTIF ... done.
Permanent post


Just want to show, that we don't need to do everything by ourselves... if somebody have already done this... Use libs! :)

Solution in Java:

Java


Take one corner of the triangle, create a line thru that corner and zero. That line should cross the line-piece between the other two corners. If not, zero is not in the triangle. If it is, take another corner and check if a line thru that corner and zero crosses the line-piece between the remaining corners, if not zero is not in the triangle, else it is.

Programmed it in Smalltalk, bit to much code to post. Works for any point.
Permanent post


I simply used the definition of the cross product, but I found this one great fun. More computational geometry please !
Permanent post


CMU Common Lisp, compiled.  Initially I drew vectors along the points forming a counter-clockwise path, then drew a vector from each point to a putative origin somewhere in the interior; the cross product of each edge vector with the center-pointing vector originating at its tail had to be positive if the origin was in the interior.  Doing the math resulted in discovering that the calculation was the same as drawing a displacement vector from the origin to each point, again in the order of a counter-clockwise path.  My original code had a function that took three points and returned them rearranged into a counter-clockwise path; the program worked.  I then figured out that if the path was clockwise then all the cross products would be negative.  So I changed the program to test if the cross-products were of the same sign and removed the rearrangement function; it speeded things up a tad (ca. 1 ms out of 14).

My only preprocessing was to surround each line of data with parentheses in emacs; this way each read brings in all the data for one triangle (this simplifies the code structure but has little effect on speed -- still gotta get 6000 numbers off the HDD).

It now takes about 13 ms.

LISP


src = '''-340,495,-153,-910,835,-947
-175,41,-421,-714,574,-645'''.split('\n')
src = [[int(y) for y in x.split(',')] for x in src]

def inner_product(x, y, o=(0, 0)): return (x[0]-o[0])*(y[1]-o[1]) - (x[1]-o[1])*(y[0]-o[0])

sum = 0
for tri in src:
  if (0 < inner_product((tri[0], tri[1]), (tri[2], tri[3]))\
    and 0 < inner_product((tri[2], tri[3]), (tri[4], tri[5]))\
    and 0 < inner_product((tri[4], tri[5]), (tri[0], tri[1])))\
    or\
       (0 > inner_product((tri[0], tri[1]), (tri[2], tri[3]))\
    and 0 > inner_product((tri[2], tri[3]), (tri[4], tri[5]))\
    and 0 > inner_product((tri[4], tri[5]), (tri[0], tri[1]))):
    sum += 1
print sum
Permanent post


I may have overcomplicated this a bit too.

I noted that a triangle is the intersection of 3 half planes. Based around each of the lines in the triangle. So I computed the normal vector for each of these half planes, and then used the information that the third point needed to lie in the half plane to see if the scalar product needed to be greater than or less than.

I then did the same for 0 to see if it was also in the half plane. If it did not lie in one of the half planes, then it did not lie in the triangle either, and could thus be rejected.
Permanent post


Like some of you I used the cross product to find the area of the triangle. Then added the cross products for all pairs of points to see if it equaled the area (and thus it had to be inside).

Perl



For every triangle I checked every side of it this way:
 Let the function of side AB be f(x).
 if f(x of C) - (y of C) and f(x of 0) - (y of 0) are both positive or negative together, then they are on the same side.
 if true for all 3 sides, the origin is in the triangle.

* There were 3 triangles that had sides which are not a function. I printed them out and all the dots had negative x coordinates, so they were bad.
Permanent post


elementary geometry :)

Ruby: 0.012 seconds

Ruby

Tue, 31 Jul 2007, 07:02 
pvz  
Sweden  
   Quote   Report    0
After some thinking, I ended up doing this:

- Imagine a line going from the origin to every one of points A, B and C.
- Check the angles between these three lines. If any angle is greater than 180Ãƒâ€šÃ‚Â°, it means the entire triangle is going to end up not containing the origin. (It's hard to explain in text. Draw it on paper, and it'll be clear. :-)

My implementation in Python of this algorhithm runs in well under a second on my Powerbook G4 1.5 GHz.



It's been long enough since I looked at computational geometry for all formulae to have disappeared from my head, so I derived this one from scratch, noting that A needs to be on the same side of the line BC as the origin, and similarly for B and C. The end calculation looks very similar to the cross product solutions.
Python



this was rather easy, judging whether a point is inside a triangle is easy using areas, for which you only need integer arithmetic (you can compare 2*surfaces)
Permanent post


Another "is at least one line above the origin and one below" solution.

Perl


Easy enough in Matlab, using inpolygon.
Permanent post


I think my method is the strangest one. Using the fact that the total area is equal to the area of the 3 triangles the origin can make with the other points.

from math import sqrt
class point:
    def __init__(self, x, y):
        self.x,self.y=x,y

def check(p1,p2,p3):
    def dist(p1,p2):
        return sqrt((p2.x-p1.x)**2+(p2.y-p1.y)**2)
    def heron(p1,p2,p3):
        a=dist(p1,p2)
        b=dist(p1,p3)
        c=dist(p2,p3)
        s=(a+b+c)/2
        return sqrt(s*(s-a)*(s-b)*(s-c))
    a=(heron(point(0,0),p2,p3)+heron(p1,point(0,0),p3)+heron(p1,p2,point(0,0)))/heron(p1,p2,p3)
    if a>1-10**-10 and a<1+10**-10:
        return True
    return False
    

#read in triangles
f=open("triangles.txt","r")
triangles=[]
a=f.readline()
while len(a)>1:
    l=[int(i) for i in a.split(",")]
    triangles.append([point(l[0],l[1]), point(l[2],l[3]), point(l[4],l[5])])
    a=f.readline()
f.close()

n=0
for triangle in triangles:
    if check(triangle[0],triangle[1],triangle[2])==True:
        n+=1
print n
Permanent post


123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy

About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:33
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 76 to 100 out of 201


Heh my solution was definitely more complicated then it needed to be, I found the unique x intercepts of all the line segments, then the same for y by finding the x intercepts of the inverse line segments. Then made sure 0 fell between for both x and y. Or if there was only one intercept, I checked to see if it was 0.
Permanent post


The first posted solution using areas of 3 sub-triangles gets my vote for elegance.  Of course I didn't think of it and did it the same way Cark did.  I basically computed the angles ABC of each tirangle, then the angle from each corner to the origin.  If the computed angle was greater then the vector to the origin lay outside the triangle, hence the origin was outside.

I probably would have used the java Polygon class if I had been thinking clearly.
Permanent post


POVray...
Haskell

Thu, 1 Nov 2007, 14:36 
Ende  
Germany 
   Quote   Report    0
Interpreting the first pair of numbers as vector A, the second as vector B, the third as vector C, and assuming that (C-A) and (B-A) are linearly independent (i.e. no degenerate triangles in the file), I calculate r and s in the affine equation (0, 0) = A + r*B + s*C.

That boils down to solving a simple 2x2 matrix.

If r and s are both positive, the origin is 'between' the rays originating from A defined by (C-A) and (B-A).
If r+s <= 1, the origin is also on A's side of B+t(C-B) (or on that line, in fact).

So, in all honesty, I check if the origin is in the interior or on any of the sides of each triangle, but I got away with it. :p


If the angles of the vector products of all the pairs of the vector from origin to a triangle points have the same sign, the triangle contains the origin:
Haskell


This may have already been stated above someplace but I did not see it when I scanned the postings.

For any closed curve which does not intersect itself the point (a,b) is inside the curve if and only if the segment [(a,b),(m,n)],where (m,n) is known to be outside the curve, intersects the curve an odd number of times. (This statement may need more precise wording.)

So I intersected the segment [(0,0),(10000,10000)] with all sides of each triangle and counted the ones that intersected an odd number of times.

I had a little trouble with integer overflow in my intersection code and had to go to 64-bit integers. I have not yet looked into why the numbers were getting so big.
Permanent post


Used Excel, and looked at the signs of the crossproducts. 
Define P1P2 = P1-P2 as the lines between the points; likewise P2P3 and P3P1.
Now for any (X1,Y1), (X2,Y2) the crossproduct is X1Y2-X2Y1; the magnitude is an area and the sign is a 'handedness'. Calculate the signs of the crossproducts P1 x P1P2 etc as the 'handedness' of each line with respect to the origin.
Check whether all 3 crossproducts have the same sign.

Plus with Excel you can graph the triangles.
Permanent post


for any triangle ABC, A and O must to be on the same semiplane determined by BC. etc.
Python

  
Permanent post


Someone else has already suggested using libs. I'm all for that, so I let the guys in Cupertino figure out the answer. I guess that pyobjc counts as python?

real   0m0.665s
user 0m0.596s
sys  0m0.066s

Pretty much all the time was spent importing Cocoa's AppKit :)

Python


Permanent post


Plenty of intersting approaches out there!

My solution in ocaml checks for each segment of a triangle if the origin is on the same side as the third point, using cross product. It runs in about 15 ms.




I also checked if the origin was of the same side of each segments using cross product and checking that all "z" parts were of same sign (if my memory is good, you can use the same approch in n-dimensional spaces to determine if points are on the same side of an hyper-plane) Here follows the code (ran in 5 ms)

C#


Some analytic geometry.
Without sqrt, abs, fractions, angles and so on.
det(
x , y , 1
x1 , y1 ,1
x2 , y2 , 2
)
for x and y =0 ( the origin ) is x1*y2 - y1*x2; If determinant is greater than zero origin is left from line, otherwise it is right.



Apologies for probably solving this very non-mathematically.

1. For each set of corrdinates determine which of the 4 quadrants it lies in.  
2. For any pairs that are in opposite quadrants (2 and 4 or 1 and 3) calculate slope and intercept.
3. Use this to determine which quadrant the intercept lies in.
4. If all 4 quadrants are spoken for then 0,0 is within the triangle.

BASIC



I think the solution of RogerHui using Heron's formula is quite elegant.  I calculated intercepts for each line segment and tested whether all four of (+x, -x, +y, -y) are included.
Python


With some code for the Point and Triangle classes obtained from http://answers.google.com/answers/threadview?id=785251 this was not too challenging.

C/C++

Permanent post


My idea is to verify that the 3 barycentrics coefficients are positive
(affine traduction of euclidian notion of crossproducts)
Very simple code ( in Ruby for this problem ) :


Using the cross product, one can check whether two points are on the same "side" of a line; doing so for the origin and the other vertex for each edge of a triangle one can check whether the triangle contains the origin:

[code]
PROGRAM triangles
  IMPLICIT NONE

  INTEGER, PARAMETER:: fu=10
  CHARACTER(len=32):: filename="102_triangles.txt"

  LOGICAL:: containsOrigin

  INTEGER:: ios
  INTEGER:: ax, ay, bx, by, cx, cy
  INTEGER:: cnt=0

  OPEN(UNIT=fu, FILE=filename, IOSTAT=ios, ACTION="read", STATUS="old")
  readloop: DO
    READ (fu, *, IOSTAT=ios) ax, ay, bx, by, cx, cy
    IF (ios/=0) EXIT readloop

    IF (containsOrigin(ax, ay, bx, by, cx, cy)) THEN
      cnt=cnt+1
    END IF
  END DO readloop
  CLOSE(UNIT=fu)

  WRITE (*,*) cnt

END PROGRAM triangles

! Check if a triangle contains the origin
! Do this by checking if the origin is on the same side as the other
! vertex for each edge.
FUNCTION containsOrigin(ax, ay, bx, by, cx, cy)
  IMPLICIT NONE
  INTEGER:: ax, ay, bx, by, cx, cy
  LOGICAL:: containsOrigin

  LOGICAL:: sameSide

  containsOrigin=( &
    sameSide(ax, ay, bx, by, cx, cy, 0, 0) .AND. &
    sameSide(bx, by, cx, cy, ax, ay, 0, 0) .AND. &
    sameSide(cx, cy, ax, ay, bx, by, 0, 0))
    
END FUNCTION containsOrigin

! Check if two points are on the same side of a given line segment
FUNCTION sameSide(ax, ay, bx, by, px, py, qx, qy)
  IMPLICIT NONE
  INTEGER:: ax, ay, bx, by, px, py, qx, qy
  LOGICAL:: sameSide

  INTEGER:: getCrossZ
  INTEGER:: crossZ1, crossZ2

  crossZ1=getCrossZ(bx-ax, by-ay, px-ax, py-ay)
  crossZ2=getCrossZ(bx-ax, by-ay, qx-ax, qy-ay)

  sameSide=(crossZ1<0 .EQV. crossZ2<0)
END FUNCTION sameSide

! Calculate z coordinate of cross product
FUNCTION getCrossZ(ax, ay, bx, by)
  IMPLICIT NONE
  INTEGER:: ax, ay, bx, by
  INTEGER:: getCrossZ

  getCrossZ=ax*by-ay*bx
END FUNCTION getCrossZ
[code]
Permanent post


geometric idea:

One triangle is containing the origin only if he cut the Y axes two time: one time with an y<0 the other with y>0



Interesting fact: if you use the second vertex's y-coordinate as the third vertex's x-coordinate, the answer is 245.

!#!@#!#!# Typos!
Permanent post


Ruby

Ruby


well, maybe I've got carried away a little bit. Anyway the idea is taken from math world:

http://mathworld.wolfram.com/TriangleInterior.html

C/C++


I did it the same way as gauchopuro did.
I implemented the barycentric coordinates in PASCAL     (not very excellent, but it works).


Thu, 8 May 2008, 15:37  
    
   Quote   Report    0
Here I am using the barycentric technique in Haskell, runs pretty much instantly.


I use Standard ML. It was easy.



123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy


About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:33
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 101 to 125 out of 201


Wow! There are so many nice solutions to this problem! I have tried to summarize what I found so far here (whichever code I could understand, but not Mathematica, J or K, sorry guys). I was able to identify 10 different methods. I list them according to their popularity:

1. Analyzing if the origin lies by the same side to all sides of the triangle (25 people):
    1a. the origin and the third vertex lie by the same side of the line through another two vertices (16)   
    1b. the origin lies in the "positive" half-plane (as defined by the normal vector) for any side of the triangle (9)

2. Computing the sum of areas of smaller triangles formed by the origin and the vertices and comparing it to the area of the whole triangle (22 people):
    2a. counting areas via cross products/determinants (16)
    2b. counting areas via Heron's formula (6)

3. Barycentric coordinates/convex hull approach (20 people):
    3a. computing barycentric coordinates of the origin with respect to the vertices, and checking if they are in between 0 and 1 (13)
    3b. solving the affine equation for the origin to lie inside the convex hull of the three vertices (as per Mathworld "Triangle Interior" article) (7)

4. Checking if x-intercepts (and/or y-intercepts) of sides have different signs (19 people)

5. Checking if all angles AOB, BOC, COA "wind up" in the same direction, i.e. if the three cross products OA x OB, OB x OC, OC x OA have the same sign. A variant of this checks if cross products AO x AB, BO x BC, CO x CA have the same sign. (15 people)

6. Computing the angles from the origin to vertices and comparing their sum to pi or 2*pi (14 people)

7. Using ready-made graphics libraries or routines which give the answer right away (11 people)

8. Computing the parity of the number of intersection points of triangle's perimeter with some ray from the origin to infinity (4 people)

9. Checking if every two vertices lie by the *different* sides of the line through the origin and the third vertex (3 people)

10. Using contour integration along the triangle's perimeter of the function f(z)=1/z (which has a pole at the origin) and checking the answer against 2*pi*i (2 people)

=========================================
I will keep updating numbers seeing what people post after this message. Last updated post by: tdug1991
Permanent post


228
Total Time : 318 Milisec

Java

Not the cleanest code I've ever written, but it works.

Python

With A, B and C as the points of the triangle, P as a fourth point and a() as a function that finds the area of a triangle, P is inside ABC if a(ABC) = a(PBC) + a(APC) + a(ABP).


Looks a little complicated, but is actually quite easy and runs fast. The comparison in "process_triangle" is due to rounding errors. Still everything works correctly to the point.

Pascal

1000 triangles with P(0; 0) 228 inside and 772 outside

real  0m0.017s
user  0m0.004s
sys 0m0.007s

(Output also contains the coordinates and a reference to inside/outside. Still everything runs in less than 20 ms.)


Funny problem :-)
My solution is based on the determinant of 2x2 matrix made by coordinates of a consecutive pair of triangle vertex.
If the origin is inside the three determinant must be all positive or all negative, depends of the order of point loaded from file, with triangle visited clockwise or counterclockwise.

In other words, the triangle P1(x1,y1), P2(x2, y2), P3(x3, y3) cover the origin if the determinants


∣∣∣x1y1x2y2∣∣∣>0|x1x2y1y2|>0

∣∣∣x2y2x3y3∣∣∣>0|x2x3y2y3|>0

∣∣∣x3y3x1y1∣∣∣>0|x3x1y3y1|>0


or are all negative.

Rust

The total execution time is about 15 ms on i5 pc.


Similar to others.  0.15 seconds.  

Python

zhujiangtao  
China 
   Quote   Report    0
The method to determine whether P in the the triangle ABC is described in http://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html

Here is my code

Python

Anonymoose
D   
   Quote   Report    1
The origin lies inside the triangle if a line drawn outwards from the origin crosses the boundary of a triangle an odd number of times.  So, consider each pair of points as a line segment, check if crosses the y-axis, and find the y-intercept if it does.  If the y-intercept is positive, a ray extending straight up from the origin crosses that side of the triangle.  I went into my box of UNIX power tools and pulled out AWK, ever faithful since the 1970s.

Awk is awksome (pun intended) at processing text files like this, and it rawked (oh brother) this problem.  Running a shell script to solve the problem 100 times yields the following runtimes:

real  0m0.410s
user  0m0.314s
sys 0m0.097s

So figure the solution takes roughly 3ms to run on my system.

awk

Slightly long in Java ; had to create my own Vector class for this , yep everything done from scratch.
Java

Method: This is probably longer but it's the only way I thought I could do it
To check if a point is in the triangle , all we need to do is evaluate the sign of the cross product of the vectors that contain the point. Too long to explain but if you draw it out you'll get it.

Tue, 13 Jan 2015, 02:39 
pabbelt
Python    
   Quote   Report    0
Did mine in python, used classes to learn oop better took about 20 milliseconds to run, what I realized was that if a point x is to be in triangle abc the area of abc = area xbc + area xac + area xab.

Python

C/C++


Haskell

Blashyrkh
Python    
   Quote   Report    0
If the origin is inside the triangle, then the angle between any two "neighbouring" vectors must be <= pi.
Ugly Python code:

Python

Ray tracing from the origin and find out wether the ray meets the triangle once (previously trio-oriented).


I used the opportunity to pull in a maths library (JScience), just for the Vector and since I have a feeling that this will prove to be useful for many problems to come ...

Also, even though I (like many others) have thought about the "same sign of perpendicular vector to (0,0)" as a first solution, I ended up using the Barycentric Technique, see http://www.blackpawn.com/texts/pointinpoly/ (nice Flash applet!)

Scala


I did in simple way.
Area of ABC = Area of PBC + Area of PAC + Area of PAB
Here is my code.
Python

This problem was pretty easy, but it's good that they aren't all really hard ... yet.  I thought of several ways to solve this: checking if the angles add up to 2pi, checking if the area is right, or checking if the point is on the correct side of each line, but I decided to use barycentric coordinates.  That is basically a system that specifies every point based on its distance from each vertex: the three coordinates add up to 1 and are all between 0 and 1 if the point is in the shape.  Here is my program, which runs in 3 ms:
C/C++

Python

Or you can utilize branch cuts of acos() to see if vectors from origin to the vertices adds up to 2 * pi (Precision might be a problem in some cases):

Python

Key observation: draw rays from the origin to the the three vertices to verify that the triangle contains the origin if and only if each of the angles between those lines is less than 180 (excluding the fringe case of the origin being one of the vertices, which doesn't happen in this problem).

Then, encode the sign of the sine of the angle in the cross product cp between these rays (seen as 3d vectors with trivial z coordinate). All the angles being less than 180 is equivalent to all three cross products having the same sign. Don't worry about which sign convention you pick, as long as you are consistent when you travel along the vertices i.e  cp(pt1,pt2), cp(pt2,pt3), cp(pt3,pt1)

Python

Anand Hariharan  
India 
   Quote   Report    0
The data in the input file being comma separated, got me to pursue a spreadsheet based solution.

Most spreadsheets number columns with letters and rows as numbers.  The input data took up six columns viz., A through F.  These were the formula I entered in the columns from G through P (1000th row is taken as an example):

   Syntax highlighter disabled

Then, one simply counts the number of cells in column P that have a value of 2 PI.


A little googling led me to the idea of barycentric coordinates (http://en.wikipedia.org/wiki/Barycentric_coordinate_system)

If all barycentric coordinates of a point are in the (open) range (0, 1) then the point is in the reference triangle.

Python

Tried to do the Barycentric coordinates, but got 109 as an answer. Instead, tried the area method, which worked.
Python

I derived my method of Barycentric coordinates by this thread:
http://math.stackexchange.com/questions/51326/determining-if-an-arbitrary-point-lies-inside-a-triangle-defined-by-three-points
I used the answer starting with "Method" in a big font.

Can anyone tell me what is wrong with this code?
Python


0.17 s. Method from MathWorld  Triangle Interior.
C/C++

Lewistrick said
Tried to do the Barycentric coordinates, but got 109 as an answer. Instead, tried the area method, which worked.
Python

I derived my method of Barycentric coordinates by this thread:
http://math.stackexchange.com/questions/51326/determining-if-an-arbitrary-point-lies-inside-a-triangle-defined-by-three-points
I used the answer starting with "Method" in a big font.

Can anyone tell me what is wrong with this code?
Python


Your problem is occurring in the inequalities you test for when incrementing n_triangles.
You are using the fact that 0 < a/d <1 is equivalent to 0 < a < d to avoid computationally expensive division.  Unfortunately, this doesn't hold if both a and d are negative.
0 < -1/-2 < 1 is true, but 0 < -1 < -2 is not.
In this problem, some triangles have at least one of (wA, wB, wC) and d negative at the same time, and these are giving inaccurate results.

You could add a test on the signs of the weights and the scalar d, and use the absolute values if both are negative, or you could do the division.  Both should give the expected answer.


For the triangle to contain the origin it needs to intercept the x axis twice, once positive and once negative. And the same for the y axis, giving a total of 4 interceptions.

This was pretty easy to code and runs in about 20ms. 

But it gives 227 as the answer! I quickly realised that a point on the axes would cause problems. This only happens once. 227 + 1 = 228.

Python

123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy


About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:33
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 126 to 150 out of 201



I tried three different ways (barycentric, dot product, parametric):

Erlang

Found X-Intercepts of the triangle legs and verified that the Origin was contained.  0.014 seconds

I can't claim any originality in this solution, but I thought I would at least make it as pretty as possible.

Python

Some great Mathematica answers here, but none as short or fast as this!  (you know you want to push that "kudos" button...go ahead... do it!)
Mathematica

This took 30 ms.

Python

I used informations from this Mathworld page (I used the same notations in the code).

Sat, 4 Apr 2015, 13:59 
bobbobson
C/C++   
   Quote   Report    0
I used the dot product approach to solve this. I stored the coordinates in a file called "coords.txt". I broke up the code into several self-explanatory functions to make it easier to spot errors.

C/C++

Just a liiiittle bit Object-Oriented :P

My code in Python:

Python

I'd just like to say I wasted about 30 minutes on this problem trying to figure out what the origin of a triangle was--I thought it was a term I had just forgotten. Finally I got what "origin" meant and literally slapped the heel of my hand against my forehead. 


Mathematica

Or
Mathematica

Using numpy. 

Python

9 ms VB 5.0, finding equations of the three lines as y = m x + a, or x coordinate of vertical line and see if each point is on the same side of the opposite side as is the origin.

BASIC


Simple Java
Java

Java

I cheated a little by adding a comma to the end of each line, so I could pass the whole text as an argument to the method. Other than that, pretty straightforward:

Java

I used the MathWorld implementation which runs in about 55ms in MATLAB once the triangle data is imported.

Matlab


2. 2 points share a quadrant and the third is in a diagonal quadrant - The triangle contains origin if the lines connecting the lone point to the points in the diagonal quadrant pass through different quadrants. 

All other triangles could be discounted. 

This solution made my code a bit more lengthy than most but it still runs in 44ms. 

C#

Solution in J, converting to barycentric coordinates by solving systems of linear equations:

J


Assembly

If a triangle contains the origin, at least two of the points must lie in diagonaly opposite quadrants. If the third pojnt is in another quadrant it y value must have the opposite sign of the line between the first two points crossing with the y-axis. If two points is in the same quadrant, the lines connecting them with the third point must cross the y axis on either side of the origin.
Code runs in 26 ms.
Python

Compute sum of all angles between origin and edges and compare it with 2 * pi
Python

I am impressed with the number of ways to solve this problem. 

I used the idea that angles between adjacent rays from the origin to the three vertices must not exceed 180°


Used barycentric coordinate systems to verify if the origin is within the triangle. I think its the most reliable way as it is not too dependent on the computational precision.
https://en.wikipedia.org/wiki/Barycentric_coordinate_system


If O is in ABC
angle(AOB) + angle(BOC) + angle(COA) = 2pi

LISP

Wed, 12 Aug 2015, 22:53 
AdmiralWen  
USA 
   Quote   Report    0
Python

123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy

Loading [MathJax]/extensions/Safe.js
About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:33
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 151 to 175 out of 201

Sat, 15 Aug 2015, 15:57 
Jelmer  
Netherlands 
   Quote   Report    0
Ruby

_Ruby_


i used Heron's formula in this case- if the area of ABC equal to the sum of the areas of AOC+BOC+AOB than the point is in the origin


def s(x1,y1,x2,y2,x3,y3):
    t=abs(x1*(y3-y2)+x2*(y1-y3)+x3*(y2-y1))*0.5
    if t>0:
        return t
    return -1

def heco(x1,y1,x2,y2,x3,y3):
    return s(0,0,x2,y2,x3,y3)+s(x1,y1,0,0,x3,y3)+s(x1,y1,x2,y2,0,0)==s(x1,y1,x2,y2,x3,y3)

def f():
    count=0
    for i in range(1000):
        if heco(list1[i*6],list1[6*i+1],list1[6*i+2],list1[6*i+3],list1[6*i+4],list1[6*i+5],)==True:
            count+=1
    return count


Quite a novel (read: silly) solution here, I used the 2D game-dev framework, 'LÖVE' to create each triangle as a polygon object, then used the in-built physics library to check whether the point (0,0) collided with that object.

It amused me, anyway.

Lua


15ms in Matlab. I got the angles of all three points for each triangle, sorted them, and made sure that the angle between any two points was less than pi for it to include the origin.

Matlab

macklejesus  
USA 
   Quote   Report    0
I found a site with three different methods of checking if a point is inside a triangle and implemented all three of them. And I made a nice post describing the math behind all three, but then lost it. Ugh. So instead, I'll just post my code and results, and you can read the blog post linked to for the methods.

JavaScript

The main function finds a solution in 0.39 ms. Loading the list of points takes 0.34 ms, and each checking function takes the following:

barycentric : 0.053 ms
parametric  : 0.058 ms
dotProduct  : 0.065 ms

Sat, 29 Aug 2015, 22:19 
bormolino  
Germany 
   Quote   Report    0
Here my solution in java - thanks to this article: https://en.wikipedia.org/wiki/Triangle#Using_coordinates

Result: 228

real  0m0.161s
user  0m0.231s
sys 0m0.022s

Java


Geometric problems are great, there are always so many different approaches.

Barycentric coordinates

180µs
Rust


Obviously I see that there are a lot of easier ways to do this but the hope is someone will feel better knowing someone else way over coded this solution to.

Procedure: read each line into list. For each combination of x's(and y's), if x1*x2<=0 (or y1*u2<=0) then the connecting line intersects y-axis(x-axis). Put it in point slope and find intersection. The origin is contained if all four axis are crossed.

F#

Python



(Time: 15ms)
Python

After drawing out a couple triangles, I realized that a point (the "target") will be contained by a triangle iff, for each of the three lines that passes through vertices of the triangle, the triangle point not used to make the line and the target point are on the same side of the line.

I could have done something fancy with combinations to cover all three cases in a single loop, but this way was clearer:

Python3





In scilab :
Scilab

Inzhevatkin  
Russia  
   Quote   Report    0
Wow, this task has a lot of solutions) My way is comparing xyz triangle area to xyo, yzo and zxo triangles' areas sum. Isn't the best way probably but still
Python



Matlab rocks!
Matlab



Haskell

Approach: If two of the three sides have a y-intercept, and the y-intercepts have different signs, the origin is contained within the triangle.

Java

aristarchos  
USA 
   Quote   Report    0
Python 3.5:

Python

Days              : 0
Hours             : 0
Minutes           : 0
Seconds           : 0
Milliseconds      : 53
Ticks             : 537474
TotalDays         : 6.22076388888889E-07
TotalHours        : 1.49298333333333E-05
TotalMinutes      : 0.00089579
TotalSeconds      : 0.0537474
TotalMilliseconds : 53.7474


Java

I used the rule for a triangle to contain the origin to solve this problem.

def p102_area(d):
  #d 0  1   2  3   4   5
  #  xa ya  xb yb  xc  yc

  d = [ int(i) for i in d ]
  ## area of AOB + BOC + AOC (where O is the origin)
  a = 0.5*(math.fabs( d[2]*d[5] - d[4]*d[3]))
  a += 0.5*(math.fabs( d[4]*d[1] - d[0]*d[5]))
  a += 0.5*(math.fabs( d[0]*d[3] - d[2]*d[1]))

  ## area of ABC
  b = 0.5*( math.fabs( d[0]*d[3] - d[0]*d[5] + d[2]*d[5] - d[2]*d[1] + d[4]*d[1] - d[4]*d[3] ))

  ## if triangle contains origin, ABC = AOB + BOC + AOC
  if math.fabs(a-b) < 1.e-5:
    return True
  else:
    return False

def Problem0102():
  outp = """102) find the number of triangles for which the interior contains the origin"""
  with open('input/Problem0102.Input.txt','r') as f:
    c = 0
    for l in f:
      d = l.strip().split(',')
      if p102_area(d):
        c += 1
  outp += "\nAnswer: " + str(c) + '\n'



In other words, if you are standing at any point on the triangle and are looking towards the origin, you should always see one point to the left of it and another to the right. Otherwise, the origin lies outside of the triangle.


Other methods I've seen in this thread are quite clever.

Wed, 30 Dec 2015, 18:21  
neuron04  
USA 
   Quote   Report    1
Same approach as most other people, slightly easier/simpler code 

Python

nonrecursive
Python    
   Quote   Report    0
Runs in roughly 0.02 seconds.

Python


123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy


About
Archives
Recent
Progress
Account
News
Friends
Statistics
Sign Out
Logged in as oregember
Fri, 13 May 2016, 16:33
RSS Feedsecure_icon
Problem 102
123456789   Go to Page: 
5/5 Kudos remaining
Showing posts 176 to 200 out of 201


I used the rule "a point is contained in a polygon, if the number of intersections of some line drawn from this point with the sides of the polygon is odd".
I used the positive x-axis as this line, after checking that no edge lies on the x-axis (and made some trivial errors in computing the intersection points ;-) ).
My code (in Java) runs in 33ms


The basic at the solution of this task is the following simple reason (I didn't meet this method at a forum) - if the triangle contains a point of the beginning of coordinates (0,0), - that all points lying on its sides (in the sum) surely are in four quadrants of the Cartesian plane.
For definition of through what quadrants there passes the straight line

                                    y = k*x + b

it is enough to define only signs of  values k and b (at the set points of a and b through which there passes this straight line)
Haskell

Python

Mathematica

python 2.7
vector and matrix
Python

Octave (Runtime = 0.24s)

Summary of Approach: The triangles in the file when drawn on the Cartesian plane will always have either no y-intercepts or two y-intercepts. The program starts by ignoring the cases where the triangle has no y-intercepts by looking at the max and min of the x coordinates. Since some of the sides of the triangle in the file have vertical slope, the program incorporates a negligible adjustment to the x-coordinates when you have a vertical slope. The program then determines the two (guaranteed) y-intercepts of the triangle. When the y-intercepts have opposite signs, the origin must be within the triangle. It loops through the triangles and adds up the successful cases.

A=zeros(3,2);s=0;
for i=1:1000
  A(1,:)=T(i,1:2);A(2,:)=T(i,3:4);A(3,:)=T(i,5:6);
  if min(A(:,1))<0 || max(A(:,1))>0 || min(A(:,2))<0 || max(A(:,2))>0
    if A(1,1)==A(2,1) || A(1,1)==A(3,1)
      A(1,1)=A(1,1)+10^-5;
    end
    if A(2,1)==A(3,1)
      A(2,1)=A(2,1)+10^-5;
    end
    mAB=(A(2,2)-A(1,2))/(A(2,1)-A(1,1));
    mAC=(A(3,2)-A(1,2))/(A(3,1)-A(1,1));
    mBC=(A(3,2)-A(2,2))/(A(3,1)-A(2,1));
    a=mAB*(-A(1,1))+A(1,2);
    if A(1,1)*A(2,1)>0
      a=0;
    end
    b=mAC*(-A(1,1))+A(1,2);
    if A(1,1)*A(3,1)>0
      b=0;
    end
    c=mBC*(-A(2,1))+A(2,2);
    if A(2,1)*A(3,1)>0
      c=0;
    end
    B=[a,b,c];B=B(B~=0);
    if prod(B)<0
      s=s+1;
    end
  end
end
disp(s)


Mathematica

Using cross products. Given two vectors  
→
v
 =(v1,v2),  
→
w
 =(w1,w2), the number cp( 
→
v
 , 
→
w
 )=v1w2−w1v2 is dependent on the direction of rotation from  
→
u
  to  
→
v
 . It is positive for counterclockwise rotation from  
→
v
  to  
→
w
  and negative for clockwise rotation. Let  
→
u
 ,  
→
v
  and  
→
w
  be the vectors from the origin to the vertices of a triangle, the origin is inside the triangle if and only if the numbers cp( 
→
u
 , 
→
v
 ), cp( 
→
v
 , 
→
w
 ) and cp( 
→
w
 , 
→
u
 ) are all non-negative or non-positive.

0.076346s

Haskell


I also graphed them -- but only because I was curious how to graph using the graphics.py module for python.  

Python

Barycentric coordinates are cool, haven't used them before
https://stackoverflow.com/questions/2049582
Haskell

I found a rather different approach to this problem. Instead of using barycentric coordinates, I used area to solve this problem. Assume that Point P is the origin, and Points A, B, and C are the vertices of the triangle. Then: ABC = APB + APC + BPC

So, if the origin is not inside the triangle, this equation would not be true. Using this conditional, the program took only 5 ms.

Python

Python

Idea of solution: using the linear operator T translate all points (A, B, C, O(0,0)) to points
A′(1,0),B′(0,1),C′(0,0),O′=T(O).
This linear operator is 
T(VP)=( VA−VC,VB−VC )−1(VP−VC)=( AX−CX,BX−CX  AY−CY,BY−CY )−1( PX−CX  PY−CY )

As a result if XO′>0, YO′>0 and XO′+YO′<1, then interior of triangle ABC contains the origin
Mathematica

real    0m0.004s
user    0m0.000s
sys     0m0.000s

C/C++

I did this in Excel, finding the x- and y-intercepts and checking whether they fall between the coordinates and, if so, whether there was one on each side of the origin.


Alright, here we go.

To explain this I assume you know about vectors in 2D, but all you need to know is about what is means to multiply a vector by a scalar, and to add vectors.

You are given two vectors in R2, that is, the Euclidean plane. Call them  
→
u
 , 
→
v
 , which represent, respectively, the points A1,A2. Also, let  
→
w
  represent some other point, N, and denote the origin as O. 


A known result from Linear Algebra says that if (and only if) the vectors are independet, then there is exactly one pair of numbers, α,β, so that α 
→
u
 +β 
→
v
 = 
→
w
 .
To those who don't know: When I say that two vectors are independent, in the Euclidean plane, that means that one can't be "scaled" to be the other vector. The vectors are  not independent (beware the double negation!): (2,1),(4,2) - the second is just the first one scaled by 2.

Here is the code which finds these α,β, with u=(a,b),v=(c,d),w=(p,q). 
Ruby


What was that good for? well, with these two values, and the drawing of what I describe in the "you are given" paragraph (in your head or on paper), look at the triangle $OA_1A_2.AknownresultsaysthatthepointNwillbeinsidethetriangleifandonlyif\alpha,\betaarebothpositiveandtheirsumislessthen1.Hereisacodethatisgiventhevectorsu,v(eachasarray)andthethirdpointC$ (also, as an array). The function checks if the point is within the triangle:
Ruby

Armed with that, we are almost ready to tackle the problem. There is just one thing left - what I presented works only if one vertex of the triangle is the origin, but we want to check if the origin itself is in the triangle. Well, all you need to do is that when given the vertexes (x1,y1),(x2,y2),(x3,y3), you "move" the axes to (x1,y1). Now, the origin becomes (-x1,-y1), and any (x,y) becomes (x-x1,y-y1). Okay, we're ready, off we go:

Ruby

Well, it's been fun, Project Euler. See ya in other problems :)


jerryhanjt    
   Quote   Report    0
Python 30ms:

First i've tried to add the angles of (a,b), (b,c), and (a,c), wich should add up to 360° or 2*pi if the triangle contains the origin, but the angle function (using acos and therefore using double precision IEEE floats, which round to 53 binary digits of precision and have limits on range ) was not able to produce exact results (e.g the angle was 1.000000000000000141357985843 instead of 1.0) so i used the python sympy library wich did all the work for me ;)

import urllib
import numpy as np
import sympy

txt = urllib.urlopen("https://projecteuler.net/project/resources/p102_triangles.txt").read()
rows = txt.split("\n")
rows = [x.split(",") for  x in rows]

A = [x[:2] for x in rows]
B = [x[2:4] for x in rows]
C = [x[4:] for x in rows]

ans = 0

for i in range(1000):
    a = np.array([int(A[i][0]),int(A[i][1])])
    b = np.array([int(B[i][0]),int(B[i][1])])
    c = np.array([int(C[i][0]),int(C[i][1])])

    x = sympy.geometry.Triangle(a,b,c)

    if x.encloses_point(sympy.geometry.Point(0,0)):
        ans += 1

print ans


Pseudocode:

1. if all points are on either left (x<0) or right (x>0) side -> skip
2. make sure two points are on the left side (flip x sign if necessary) -> A,B
3. check if A-C and B-C intersect y axis on oposite side

python3

A must read article for this particular question: Barycentric coordinate system
Takes about 0.01 seconds
Python

Python

If a=(ax,ay), b=(bx,by) and c=(cx,cy) are the points of the triangle, then an equation of the line lab through a and b is (x,y)=(b−a)t+a, and an equation of the line lc through the origin and c is (x,y)=cτ.
lab and lc intersect when
t=t′=
cxay−cyax
bxcy−bycx+cxay−cyax
 

or
τ=τ′=
axby−aybx
cxby−cybx+axcy−aycx
 
,
so the point of intersection is r=cτ′.

The triangle contains the origin if
1. the distance between c and the origin is less than the distance between c and $r$,
2. r≠a and $r \neq b$,
3. $0 < t' < 1$,
4. and τ′<0.


C/C++

KEY: 937345_bRc93K7dl1bxqB00ndPD5SluCjwqwBUi
C/C++

Use Heron's formula for the area of a triangle given the lengths a,b,c of the sides
   A = sqrt s*(s-a)*(s-b)*(s-c)
where s is the semiperimeter 0.5*(a+b+c).
Apply Heron's formula to the whole triangle. Apply Heron's formula to the 3 triangles formed 
by the origin and each of the 3 pairs of points.  The origin is in the interior if the area of the whole triangle equals the sum of the areas of the 3 triangles.
Since the problem is calculation intensive, I suspected that rounding errors in Perl were leading to an incorrect result. Initially, only 10 solutions were being found. If precision when comparing areas was relaxed and acceptable upper and low limits for the areas was introduced (I used area + or -0.1 units), the correct answer was obtained.
Perl




Brief:
    return 0 < (P.x-A.x)*(A.y-B.y) + (P.y-A.y)*(B.x-A.x)

Explanation:
// arrange points relative to A
AP = P - A
AB = B - A

// turn AB and ABY to x and y axes
ABY = (-AB.y, AB.x) // rotation by 90 deg counter-clockwise

// calculate AP.y relative to new axes
y = scalar_prod(AP, ABY)
return y > 0


123456789   Go to Page: 

Post Reply
Project Euler: Copyright Information | Privacy Policy